<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on debug-myself&#39;s blog</title>
    <link>/tags/linux/</link>
    <description>debug-myself&#39;s blog (Linux)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
      

      
    

    
    <lastBuildDate>Fri, 01 Nov 2024 23:49:06 +0800</lastBuildDate>
    
    <atom:link href="/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何优雅重启网络服务</title>
      <link>/draft/graceful-restarting/</link>
      <pubDate>Fri, 01 Nov 2024 23:49:06 +0800</pubDate>
      
      <guid>/draft/graceful-restarting/</guid>
      <description>&lt;h2 id=&#34;tldr&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#tldr&#34;&gt;
        #
    &lt;/a&gt;
    TL;DR
&lt;/div&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 交给GPT总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文介绍了&lt;code&gt;Cloudflare&lt;/code&gt;用&lt;code&gt;Go&lt;/code&gt;语言实现的能保证网络程序&lt;code&gt;graceful restarting&lt;/code&gt;的库&amp;ndash;&lt;a href=&#34;https://github.com/cloudflare/tableflip&#34;&gt;tableflip&lt;/a&gt;的实现原理.&lt;/p&gt;
&lt;h2 id=&#34;背景&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;
        #
    &lt;/a&gt;
    背景
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;对于一个持续迭代的网络服务, 变更是家常便饭. 常规的变更流程如下:&lt;/p&gt;
&lt;pre class=&#34;mermaid&#34;&gt;&lt;/pre&gt;
    graph LR
    first[&amp;#34;更新程序/配置&amp;#34;]
    second[&amp;#34;停止当前服务&amp;#34;]
    third[&amp;#34;启动服务&amp;#34;]

    first --&amp;gt; second;
    second --&amp;gt; third;
&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;更新程序/配置&lt;/strong&gt;: 当修复了已知bug或者是新增功能时, 需要更新程序. 或者是更改了配置;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;停止当前服务&lt;/strong&gt;: 为避免和新程序冲突, 需要暂停当前服务;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动新的程序&lt;/strong&gt;: 再次启动程序让新程序/配置生效;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个变更过程存在很大的问题: 变更过程会影响正在使用&lt;/p&gt;
&lt;p&gt;很多网络服务都被要求持续无间断运行, 这就意味着在 &lt;em&gt;更新服务&lt;/em&gt; 或者 &lt;em&gt;重新加载配&lt;/em&gt; 置期间不能影响用户使用, 即优雅的重启服务(&lt;code&gt;graceful restarting&lt;/code&gt;). 许多成熟的项目都支持&lt;code&gt;graceful restarting&lt;/code&gt;, 如&lt;code&gt;Nginx&lt;/code&gt;, &lt;code&gt;ssh server&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;很多场景下需要服务能保证7*24h提供服务, 但是对于一个活跃的项目而言, 更新是家常便饭. 更新一般意味: &lt;code&gt;停止-启动&lt;/code&gt;服务, 这个&lt;code&gt;停止-启动&lt;/code&gt;服务的时间窗口内就无法提供服务, 对于用户体验非常不好. 所以像&lt;code&gt;Nginx&lt;/code&gt;这样的成熟项目都是支持&lt;code&gt;gracefully restart&lt;/code&gt;.
普通项目也有&lt;code&gt;gracefully restart&lt;/code&gt;的需求;&lt;/p&gt;
&lt;h2 id=&#34;要求&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e8%a6%81%e6%b1%82&#34;&gt;
        #
    &lt;/a&gt;
    要求
&lt;/div&gt;
&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;升级过程不影响正在使用的用户;&lt;/li&gt;
&lt;li&gt;升级后新接入的用户的流量被新启动的进程处理;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tableflip&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#tableflip&#34;&gt;
        #
    &lt;/a&gt;
    tableflip
&lt;/div&gt;
&lt;/h2&gt;
&lt;h3 id=&#34;tableflip使用示例&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#tableflip%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b&#34;&gt;
        ##
    &lt;/a&gt;
    tableflip使用示例
&lt;/div&gt;
&lt;/h3&gt;
&lt;h3 id=&#34;前置知识&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86&#34;&gt;
        ##
    &lt;/a&gt;
    前置知识
&lt;/div&gt;
&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;文件: 子进程可以继承父进程的文件描述符, 文件描述符的标志位CLOEXEC;&lt;/li&gt;
&lt;li&gt;IPC -&amp;gt; pipe &amp;amp; 信号&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tableflip实现分析&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#tableflip%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90&#34;&gt;
        ##
    &lt;/a&gt;
    tableflip实现分析
&lt;/div&gt;
&lt;/h3&gt;
&lt;h2 id=&#34;应用实例&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b&#34;&gt;
        #
    &lt;/a&gt;
    应用实例
&lt;/div&gt;
&lt;/h2&gt;
&lt;h2 id=&#34;参考&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;
        #
    &lt;/a&gt;
    参考
&lt;/div&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/graceful-upgrades-in-go/&#34;&gt;Graceful upgrades in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.blog/news-insights/the-library/glb-part-2-haproxy-zero-downtime-zero-delay-reloads-with-multibinder/&#34;&gt;GLB part 2: HAProxy zero-downtime, zero-delay reloads with multibinder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q: 连接器server父子进程共享了日志文件的文件表项吗? 为什么日志给是正常?
A: 因为打开日志文件时设置了O_APPEND, O_APPEND 在多个进程或线程对同一文件描述符写入时，能避免写入冲突。操作系统会确保每次写入都是原子的，即便多个进程或线程同时写入，也不会发生写入位置交错的问题（比如写到相同的位置）。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
